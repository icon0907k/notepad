자바 컬렉션 프레임워크는 J2SE 1.2에서 처음 도입되었으며, List, Set, Map은 이 프레임워크의 중요한 인터페이스 중 일부이다. 각 인터페이스에는 해당 컬렉션 타입을 다루기 위한 다양한 메서드와 기능이 있다. 
### 1. List Interface:

- `add(E element)`
- `get(int index)`
- `remove(int index)`
- `size()`
- `addAll(Collection<? extends E> c)`
- `indexOf(Object o)`
- `clear()`
- `subList(int fromIndex, int toIndex)`
```java
import java.util.ArrayList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        // Create a List
        List<String> myList = new ArrayList<>();
        
        // add(E element): 요소를 리스트에 추가
        myList.add("Java");
        myList.add("Python");
        System.out.println("add: " + myList); // [Java, Python]
        
        // get(int index): 주어진 인덱스에 있는 요소 가져오기
        String elementAtIndex = myList.get(1);
        System.out.println("get(1): " + elementAtIndex); // [Python]
        
        // remove(int index): 주어진 인덱스에 있는 요소 제거
        myList.remove(0);
        System.out.println("remove: " + myList); // [Python]
        
        // size(): 리스트의 크기 반환
        int listSize = myList.size();
        System.out.println("size: " + listSize); // size: 1
        
        // addAll(Collection<? extends E> c): 다른 컬렉션의 모든 요소를 현재 리스트에 추가
        List<String> additionalElements = new ArrayList<>();
        additionalElements.add("JavaScript");
        additionalElements.add("Ruby");
        myList.addAll(additionalElements);
        System.out.println("addAll: " + myList);
        // addAll: [Python, JavaScript, Ruby]
        
        // indexOf(Object o): 지정된 요소의 첫 번째 인덱스 반환
        int indexJava = myList.indexOf("Python");
        System.out.println("indexOf: " + indexJava); // indexOf: -1 (not found)
        
        // clear(): 리스트의 모든 요소 제거
        myList.clear();
        System.out.println("clear: " + myList); // clear: []
        
        // subList(int fromIndex, int toIndex): 부분 리스트 반환
        List<String> originalList = new ArrayList<>();
        originalList.add("A");
        originalList.add("B");
        originalList.add("C");
        originalList.add("D");
        List<String> subList = originalList.subList(1, 3);
        System.out.println("subList: " + subList); // subList: [B, C]
    }
}
```

### 2. Set Interface:

- `add(E element)`
- `contains(Object o)`
- `remove(Object o)`
- `size()`
- `addAll(Collection<? extends E> c)`
- `isEmpty()`
- `clear()`
```java
import java.util.HashSet;
import java.util.Set;

public class SetExample {
    public static void main(String[] args) {
        // Create a Set
        Set<String> mySet = new HashSet<>();
        
        // add(E element): 요소를 집합에 추가
        mySet.add("Apple");
        mySet.add("Banana");
        mySet.add("Orange");
        System.out.println("add: " + mySet); // add: [Orange, Banana, Apple]
        
        // contains(Object o): 지정된 요소가 집합에 포함되어 있는지 확인
        boolean containsBanana = mySet.contains("Banana");
        System.out.println("contains: " + containsBanana); // contains: true
        
        // remove(Object o): 지정된 요소를 집합에서 제거
        mySet.remove("Orange");
        System.out.println("remove: " + mySet); // remove: [Banana, Apple]

        // size(): 집합의 크기 반환
        int setSize = mySet.size();
        System.out.println("size: " + setSize); // size: 2

        // addAll(Collection<? extends E> c): 다른 컬렉션의 모든 요소를 현재 집합에 추가
        Set<String> additionalElements = new HashSet<>();
        additionalElements.add("Grapes");
        additionalElements.add("Kiwi");
        mySet.addAll(additionalElements);
        System.out.println("addAll: " + mySet);
        // addAll: [Banana, Kiwi, Grapes, Apple]

        // isEmpty(): 집합이 비어 있는지 여부 확인
        boolean isEmpty = mySet.isEmpty();
        System.out.println("isEmpty?" + isEmpty); // isEmpty? false

        // clear(): 집합의 모든 요소 제거
        mySet.clear();
        System.out.println("clear: " + mySet); // clear: []
    }
}
```
### 3. Map Interface:

- `put(K key, V value)`
- `get(Object key)`
- `remove(Object key)`
- `size()`
- `putAll(Map<? extends K, ? extends V> m)`
- `keySet()`
- `values()`
- `entrySet()`
```java
import java.util.HashMap;
import java.util.Map;

public class MapExample {
    public static void main(String[] args) {
        // Create a Map
        Map<String, Integer> myMap = new HashMap<>();
        
        // put(K key, V value): 맵에 키-값 쌍 추가
        myMap.put("One", 1);
        myMap.put("Two", 2);
        myMap.put("Three", 3);
        System.out.println("put: " + myMap);
        // put: {One=1, Two=2, Three=3}
        
        // get(Object key): 지정된 키에 해당하는 값을 반환
        int valueForTwo = myMap.get("Two");
        System.out.println("get: " + valueForTwo); // get: 2
        
        // remove(Object key): 지정된 키에 해당하는 키-값 쌍 제거
        myMap.remove("One");
        System.out.println("remove: " + myMap);
        // remove: {Two=2, Three=3}
        
        // size(): 맵에 포함된 키-값 쌍의 수 반환
        int mapSize = myMap.size();
        System.out.println("size: " + mapSize); // size: 2
        
        // putAll(Map<? extends K, ? extends V> m): 다른 맵의 모든 키-값 쌍을 현재 맵에 추가
        Map<String, Integer> additionalMap = new HashMap<>();
        additionalMap.put("Four", 4);
        additionalMap.put("Five", 5);
        myMap.putAll(additionalMap);
        System.out.println("putAll: " + myMap);
        // putAll: {Two=2, Three=3, Four=4, Five=5}
        
        // keySet(): 맵에 포함된 모든 키의 집합 반환
        System.out.println("keySet: " + myMap.keySet()); // Keys in the map: [Two, Three, Four, Five]
        
        // values(): 맵에 포함된 모든 값의 컬렉션 반환
        System.out.println("values: " + myMap.values()); // Values in the map: [2, 3, 4, 5]
        
        // entrySet(): 맵에 포함된 모든 키-값 쌍의 집합 반환
        System.out.println("entrySet: " + myMap.entrySet());
        // Entry set in the map: [Two=2, Three=3, Four=4, Five=5]
    }
}

```


## List, Set, Map 비교 
### 1. List (리스트)

- **특징:**
    - 순서가 있고, 중복 허용.
    - 인덱스로 요소에 접근 가능.
    - 요소의 순서가 유지됨.
- **사용 사례:**
    - 순서가 중요한 데이터를 다룰 때 사용.
    - 동일한 값을 여러 번 저장해야 하는 경우.

### 2. Set (세트)

- **특징:**
    - 순서가 없고, 중복 불허.
    - 인덱스로 요소에 접근 불가.
    - 요소의 순서가 유지되지 않음.
- **사용 사례:**
    - 고유한 값만 필요한 경우.
    - 중복을 허용하지 않고, 순서가 중요하지 않은 경우.

### 3. Map (맵)

- **특징:**
    - 키-값 쌍으로 데이터를 저장.
    - 중복된 키는 허용되지 않으나, 값은 중복 가능.
    - 키로 값을 찾을 수 있음.
- **사용 사례:**
    - 고유한 식별자를 사용하여 데이터에 접근해야 하는 경우.
    - 키와 값의 관계를 나타내어야 하는 경우.