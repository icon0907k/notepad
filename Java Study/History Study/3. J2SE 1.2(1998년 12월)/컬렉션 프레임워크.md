자바 컬렉션 프레임워크는 J2SE 1.2에서 처음 도입되었으며, List, Set, Map은 이 프레임워크의 중요한 인터페이스 중 일부이다. 각 인터페이스에는 해당 컬렉션 타입을 다루기 위한 다양한 메서드와 기능이 있다. 
### 1. List Interface:

- `add(E element)`
- `get(int index)`
- `remove(int index)`
- `size()`
- `addAll(Collection<? extends E> c)`
- `indexOf(Object o)`
- `clear()`
- `subList(int fromIndex, int toIndex)`
```java
import java.util.ArrayList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        // Create a List
        List<String> myList = new ArrayList<>();
        
        // add(E element): 요소를 리스트에 추가
        myList.add("Java");
        myList.add("Python");
        System.out.println("add: " + myList); // [Java, Python]
        
        // get(int index): 주어진 인덱스에 있는 요소 가져오기
        String elementAtIndex = myList.get(1);
        System.out.println("get(1): " + elementAtIndex); // [Python]
        
        // remove(int index): 주어진 인덱스에 있는 요소 제거
        myList.remove(0);
        System.out.println("remove: " + myList); // [Python]
        
        // size(): 리스트의 크기 반환
        int listSize = myList.size();
        System.out.println("size: " + listSize); // size: 1
        
        // addAll(Collection<? extends E> c): 다른 컬렉션의 모든 요소를 현재 리스트에 추가
        List<String> additionalElements = new ArrayList<>();
        additionalElements.add("JavaScript");
        additionalElements.add("Ruby");
        myList.addAll(additionalElements);
        System.out.println("addAll: " + myList);
        // addAll: [Python, JavaScript, Ruby]
        
        // indexOf(Object o): 지정된 요소의 첫 번째 인덱스 반환
        int indexJava = myList.indexOf("Python");
        System.out.println("indexOf: " + indexJava); // indexOf: -1 (not found)
        
        // clear(): 리스트의 모든 요소 제거
        myList.clear();
        System.out.println("clear: " + myList); // clear: []
        
        // subList(int fromIndex, int toIndex): 부분 리스트 반환
        List<String> originalList = new ArrayList<>();
        originalList.add("A");
        originalList.add("B");
        originalList.add("C");
        originalList.add("D");
        List<String> subList = originalList.subList(1, 3);
        System.out.println("subList: " + subList); // subList: [B, C]
    }
}
```

### 2. Set Interface:

- `add(E element)`
- `contains(Object o)`
- `remove(Object o)`
- `size()`
- `addAll(Collection<? extends E> c)`
- `isEmpty()`
- `clear()`
```java
import java.util.HashSet;
import java.util.Set;

public class SetExample {
    public static void main(String[] args) {
        // Create a Set
        Set<String> mySet = new HashSet<>();
        
        // add(E element): 요소를 집합에 추가
        mySet.add("Apple");
        mySet.add("Banana");
        mySet.add("Orange");
        System.out.println("add: " + mySet); // add: [Orange, Banana, Apple]
        
        // contains(Object o): 지정된 요소가 집합에 포함되어 있는지 확인
        boolean containsBanana = mySet.contains("Banana");
        System.out.println("contains: " + containsBanana); // contains: true
        
        // remove(Object o): 지정된 요소를 집합에서 제거
        mySet.remove("Orange");
        System.out.println("remove: " + mySet); // remove: [Banana, Apple]

        // size(): 집합의 크기 반환
        int setSize = mySet.size();
        System.out.println("size: " + setSize); // size: 2

        // addAll(Collection<? extends E> c): 다른 컬렉션의 모든 요소를 현재 집합에 추가
        Set<String> additionalElements = new HashSet<>();
        additionalElements.add("Grapes");
        additionalElements.add("Kiwi");
        mySet.addAll(additionalElements);
        System.out.println("addAll: " + mySet);
        // addAll: [Banana, Kiwi, Grapes, Apple]

        // isEmpty(): 집합이 비어 있는지 여부 확인
        boolean isEmpty = mySet.isEmpty();
        System.out.println("isEmpty?" + isEmpty); // isEmpty? false

        // clear(): 집합의 모든 요소 제거
        mySet.clear();
        System.out.println("clear: " + mySet); // clear: []
    }
}
```
### 3. Map Interface:

- `put(K key, V value)`
- `get(Object key)`
- `remove(Object key)`
- `size()`
- `putAll(Map<? extends K, ? extends V> m)`
- `keySet()`
- `values()`
- `entrySet()`
```java
import java.util.HashMap;
import java.util.Map;

public class MapExample {
    public static void main(String[] args) {
        // Create a Map
        Map<String, Integer> myMap = new HashMap<>();
        
        // put(K key, V value): 맵에 키-값 쌍 추가
        myMap.put("One", 1);
        myMap.put("Two", 2);
        myMap.put("Three", 3);
        System.out.println("put: " + myMap);
        // put: {One=1, Two=2, Three=3}
        
        // get(Object key): 지정된 키에 해당하는 값을 반환
        int valueForTwo = myMap.get("Two");
        System.out.println("get: " + valueForTwo); // get: 2
        
        // remove(Object key): 지정된 키에 해당하는 키-값 쌍 제거
        myMap.remove("One");
        System.out.println("remove: " + myMap);
        // remove: {Two=2, Three=3}
        
        // size(): 맵에 포함된 키-값 쌍의 수 반환
        int mapSize = myMap.size();
        System.out.println("size: " + mapSize); // size: 2
        
        // putAll(Map<? extends K, ? extends V> m): 다른 맵의 모든 키-값 쌍을 현재 맵에 추가
        Map<String, Integer> additionalMap = new HashMap<>();
        additionalMap.put("Four", 4);
        additionalMap.put("Five", 5);
        myMap.putAll(additionalMap);
        System.out.println("putAll: " + myMap);
        // putAll: {Two=2, Three=3, Four=4, Five=5}
        
        // keySet(): 맵에 포함된 모든 키의 집합 반환
        System.out.println("keySet: " + myMap.keySet()); // Keys in the map: [Two, Three, Four, Five]
        
        // values(): 맵에 포함된 모든 값의 컬렉션 반환
        System.out.println("values: " + myMap.values()); // Values in the map: [2, 3, 4, 5]
        
        // entrySet(): 맵에 포함된 모든 키-값 쌍의 집합 반환
        System.out.println("entrySet: " + myMap.entrySet());
        // Entry set in the map: [Two=2, Three=3, Four=4, Five=5]
    }
}

```



### List:

1. **순서가 있음 (Ordered):** List는 요소들의 순서를 유지합니다. 즉, 요소가 추가된 순서대로 저장되며, 인덱스를 통해 요소에 접근할 수 있습니다.
    
2. **중복 요소 허용:** List는 중복된 요소를 허용합니다. 동일한 값을 여러 번 저장할 수 있습니다.
    
3. **인덱스 사용:** List는 인덱스를 사용하여 요소에 직접 접근할 수 있습니다. 예를 들어, `get(int index)` 메서드를 사용하여 특정 인덱스의 요소를 가져올 수 있습니다.
    
4. **구현 클래스 예시:** `ArrayList`, `LinkedList`, `Vector` 등이 List 인터페이스를 구현한 클래스입니다.
    

### Set:

1. **순서가 없음 (Unordered):** Set은 요소들의 순서를 보장하지 않습니다. 즉, 요소들이 어떤 순서로 추가되었는지는 중요하지 않습니다.
    
2. **중복 요소 불허:** Set은 중복된 요소를 허용하지 않습니다. 동일한 값을 한 번만 저장할 수 있습니다.
    
3. **인덱스 사용 불가:** Set은 인덱스를 사용하여 요소에 직접 접근할 수 없습니다. 따라서 특정 요소를 가져오려면 반복문이나 특정 메서드를 사용해야 합니다.
    
4. **구현 클래스 예시:** `HashSet`, `LinkedHashSet`, `TreeSet` 등이 Set 인터페이스를 구현한 클래스입니다.
    

### 비교:

- List는 순서가 있고 중복을 허용하는 반면, Set은 순서가 없고 중복을 허용하지 않습니다.
- List는 인덱스를 사용하여 요소에 직접 접근할 수 있지만, Set은 그렇지 않습니다.
- List는 순서를 유지하므로 요소들이 추가된 순서대로 반복문 등을 통해 접근할 때 유용합니다.
- Set은 중복을 허용하지 않으므로 고유한 요소를 유지하고자 할 때 사용됩니다