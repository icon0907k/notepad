캐시는 네트워크 리소스를 절약하고 웹페이지 로딩 속도를 높이는 핵심 요소로 웹 개발자에게 있어 필수적인 최적화 기술이다. HTTP 캐시의 동작 원리와 조건부 요청을 통해 서버와 클라이언트의 통신을 최적화하는 방법을 알아보자.
## 1. 캐시의 기본 동작 원리
캐시가 없을 경우 브라우저는 같은 리소스에 대해 반복적으로 서버에 요청을 보내고 이는 네트워크 비용과 로딩 시간을 크게 증가시킨다. 특히 네트워크가 느리거나 비용이 높은 상황에서는 이러한 방식이 매우 비효율적이다.
### 예시 : 캐시가 없을 때 발생하는 문제
- 매 요청마다 서버에 같은 이미지를 요청할 경우 서버는 동일한 데이터(`star.jpg`)를 다시 전송한다.
- 네트워크 대역폭이 계속 소모되며 로딩 시간도 길어진다.
## 2. 캐시가 적용된 경우의 동작
캐시가 적용되면 첫 번째 요청 시 서버가 리소스를 전송하고 이후 요청은 일정 시간 동안 로컬 캐시에서 처리된다. 캐시가 적용된 브라우저는 설정된 시간 동안 서버에 재요청을 하지 않으므로 속도가 크게 개선된다.
### 캐시 적용의 장점
- **네트워크 사용 감소** : 캐시를 사용하면 같은 리소스를 재다운로드하지 않아도 되므로 데이터 사용량이 줄어든다.
- **빠른 로딩 속도** : 클라이언트의 요청에 대해 로컬 캐시를 사용하므로 사용자 경험이 향상된다.
## 3. 캐시 유효 시간 초과 시의 동작
캐시의 유효 시간이 초과되면 브라우저는 서버에 다시 요청을 보내 데이터를 최신 상태로 유지한다. 이때 서버가 리소스를 변경하지 않았다면 HTTP 응답 코드 `304 Not Modified`를 보내 데이터 본문을 전송하지 않고도 캐시의 유효성을 갱신할 수 있다.

---
## 4. 검증 헤더와 조건부 요청
검증 헤더는 클라이언트가 캐시된 데이터와 서버의 데이터가 동일한지 확인하는 데 사용된다. 대표적인 검증 헤더는 `Last-Modified`와 `ETag`이다.

- **Last-Modified** : 리소스가 마지막으로 수정된 시간을 기록한다. 클라이언트는 `If-Modified-Since` 헤더를 통해 서버에 데이터 수정 여부를 질의할 수 있다.
- **ETag(Entity Tag)** : 리소스 버전을 나타내는 고유 식별자이다. 서버는 리소스가 변경될 때마다 새로운 ETag를 생성한다. 클라이언트는 `If-None-Match` 헤더로 ETag를 전송해 서버에 동일한 버전이 있는지 확인할 수 있다.

#### 조건부 요청의 예시
1. **데이터가 변경되지 않은 경우** : 클라이언트가 가진 ETag와 서버의 ETag가 같다면 `304 Not Modified`로 응답하고 본문 데이터는 전송하지 않는다.
2. **데이터가 변경된 경우** : 클라이언트의 ETag와 서버의 ETag가 다를 경우 서버는 `200 OK`와 함께 새로운 데이터를 전송한다.

#### 검증 헤더의 단점과 보완
`Last-Modified`의 경우 초 단위 이하로 조정할 수 없으며 단순한 주석이나 공백 같은 변경에도 영향을 받을 수 있다. `ETag`는 이와 같은 문제를 보완하며 서버에서 버전 관리를 통해 좀 더 정교한 캐시 제어를 가능하게 한다.

---
## 5. 캐시 제어를 위한 주요 HTTP 헤더

#### Cache-Control
- **max-age** : 캐시 유효 시간을 초 단위로 지정한다.
- **no-cache**  : 캐시 저장은 가능하지만, 항상 서버 검증을 거쳐야 사용된다.
- **no-store** : 민감한 데이터는 캐시하지 않고 사용 후 즉시 삭제해야 한다.
- **must-revalidate** : 캐시 만료 후 다시 서버에 검증해야 하며 서버 오류 시 캐시 데이터 사용을 금지한다.

#### Pragma와 Expires (하위 호환용)
- **Pragma** : HTTP 1.0에서 사용하는 캐시 제어 헤더로 `no-cache`를 설정할 수 있다.
- **Expires**  : 특정 날짜를 지정해 캐시 만료일을 설정한다. 현재는 `Cache-Control: max-age`가 더 유연하게 사용된다.

---
## 6. 프록시 캐시의 활용
프록시 캐시는 클라이언트와 서버 사이에서 데이터 전송 속도를 높이기 위해 중간 캐시 역할을 한다. 특히 사용자와 원 서버가 물리적으로 먼 경우 프록시 캐시를 통해 지연 시간을 단축할 수 있다.

- **Cache-Control : public** : 여러 사용자가 공유 가능한 캐시에 저장할 수 있음을 지정한다.
- **Cache-Control: private**: 특정 사용자에게만 접근 가능한 캐시에 저장해야 함을 지정한다.
- **s-maxage**: 프록시 서버에만 적용되는 max-age로 캐시된 데이터의 유효 시간을 설정한다.

---
## 7. 캐시 무효화
데이터가 최신 상태로 유지되어야 할 때는 캐시 무효화가 필요하다. 이를 위해 아래와 같은 설정을 사용할 수 있다.

- **Cache-Control : no-cache, no-store, must-revalidate** : 중요한 데이터의 경우 항상 최신 데이터만을 로드하기 위해 설정한다.
- **504 Gateway Timeout** : must-revalidate가 설정된 상태에서 서버 접근 실패 시 발생하는 오류이다. 네트워크가 단절되면 캐시 데이터를 사용할 수 없으므로 주의가 필요하다.

---
### 8. 결론
HTTP 캐시는 사용자 경험을 개선하고 네트워크 비용을 절감할 수 있는 효과적인 방법이다. 검증 헤더와 조건부 요청을 통해 데이터를 효율적으로 관리하고 프록시 캐시를 활용해 데이터 전송 속도를 높일 수 있다. 개발자는 이러한 캐시 메커니즘을 이해하고 적절한 설정을 통해 최적의 사용자 경험을 제공할 수 있다.

**참고 예시 :**
- **ETag 사용** : 서비스 출시 기간 동안 리소스가 변경되지 않도록 동일한 ETag를 유지함으로써 데이터를 재사용하고 이후 배포 시 ETag를 업데이트하여 새로운 데이터를 캐시에 반영할 수 있다.

---
## 캐시 제어와 검증 헤더 예제
HTTP 캐시의 원리를 이해하기 위해 HTTP 응답 헤더에서 캐시 관련 설정을 예제 코드로 살펴보겠다.

### 1. `Cache-Control` 헤더 예제
서버에서 응답을 보낼 때 `Cache-Control` 헤더를 설정하여 캐시 정책을 정의합니다.
```http
HTTP/1.1 200 OK
Content-Type: image/jpeg
Content-Length: 34012
Cache-Control: max-age=3600, public
```
 **설명** : 이 응답은 `max-age=3600`을 설정하여 1시간(3600초) 동안 캐시를 사용하도록 한다. `public`은 공유 캐시, 즉 여러 사용자가 공통으로 접근할 수 있는 캐시에 저장해도 된다는 의미이다.

**참고** : 이 설정을 통해 브라우저는 해당 리소스를 1시간 동안 캐시하고 서버에 재요청하지 않는다.

---
### 2. `Last-Modified`와 `If-Modified-Since` 헤더를 사용한 조건부 요청 예제
`Last-Modified` 헤더는 리소스가 마지막으로 수정된 날짜와 시간을 나타낸다. 클라이언트는 `If-Modified-Since` 헤더를 통해 서버에 리소스가 수정되었는지 여부를 확인할 수 있다.
```http
HTTP/1.1 200 OK
Content-Type: image/jpeg
Content-Length: 34012
Cache-Control: max-age=0
Last-Modified: Mon, 10 Jul 2023 15:30:00 GMT
```

클라이언트 요청 (캐시가 만료된 이후) :
```HTTP
GET /star.jpg HTTP/1.1
If-Modified-Since: Mon, 10 Jul 2023 15:30:00 GMT
```

서버 응답 :

- **변경 없음** : 리소스가 수정되지 않았으면 서버는 아래와 같이 응답한다.
```HTTP
HTTP/1.1 304 Not Modified
```
- **변경 있음** : 리소스가 수정되었으면 `200 OK`와 함께 새로운 데이터를 전송한다.

 **설명** : `304 Not Modified` 응답을 통해 서버는 데이터를 재전송하지 않고 클라이언트는 기존 캐시를 그대로 사용하여 네트워크 사용을 줄인다.

---
### 3. `ETag`와 `If-None-Match`를 활용한 조건부 요청 예제
`ETag`는 리소스의 고유 버전 식별자로 데이터가 변경되면 새로운 ETag 값을 부여한다. 클라이언트는 `If-None-Match` 헤더를 사용해 ETag 값을 서버에 전달하고 서버는 이 값과 현재 리소스의 ETag를 비교하여 리소스가 변경되었는지 확인한다.


```http
HTTP/1.1 200 OK
Content-Type: image/jpeg
Content-Length: 34012
ETag: "a1b2c3d4"
```

클라이언트 요청 (캐시가 만료된 이후) :
```http
GET /star.jpg HTTP/1.1
If-None-Match: "a1b2c3d4"
```

서버 응답 :
- **변경 없음** :
```http
HTTP/1.1 304 Not Modified
```
- **변경 있음** :
```http
HTTP/1.1 200 OK
Content-Type: image/jpeg
Content-Length: 34012
ETag: "d4c3b2a1"
```
 **설명** : 서버는 `If-None-Match`의 값이 현재 ETag와 다르면 데이터를 갱신하여 보내고 같으면 `304 Not Modified`를 응답하여 기존 데이터를 그대로 사용하도록 한다.

---
### 4. 프록시 캐시를 위한 `s-maxage` 사용 예제
`Cache-Control: s-maxage`는 공유 캐시에서 사용할 유효 시간(max-age)을 정의한다. 클라이언트의 개인 캐시에는 영향을 주지 않으며 오로지 프록시 캐시에서만 적용된다.

```http
HTTP/1.1 200 OK
Content-Type: image/jpeg
Content-Length: 34012
Cache-Control: s-maxage=86400, public
```
**설명** : 이 설정은 프록시 캐시에서 해당 리소스를 24시간(86400초) 동안 캐시할 수 있음을 의미한다.

---
### 5. 캐시 무효화 설정 예제
특정 데이터가 민감하거나 즉시 최신 상태로 유지해야 할 때는 캐시를 사용하지 않도록 설정할 수 있다.

```http
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-cache, no-store, must-revalidate
Pragma: no-cache`는 HTTP/1.0 시절의 유산으로, **오래된 시스템이나 브라우저**와의 **하위 호환**을 위해 사용되는 설정
Expires: 0
```
**설명** : 이 설정은 캐시 사용을 완전히 금지한다. `no-store`는 데이터를 저장하지 않도록 하며 `must-revalidate`는 항상 서버에 요청하여 최신 데이터를 확인하도록 한다.

---
### 6. 전체적인 예제 : API 응답에서 캐시 제어 헤더를 사용하는 경우
RESTful API에서 자주 변경되는 데이터의 경우 캐시 제어를 적절히 설정해야 한다.  사용자 프로필 정보는 매번 최신 상태가 필요할 수 있다.
```http
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
```
**설명** : `no-store`로 설정하여 사용자 정보가 캐시에 저장되지 않도록 한다. 개인 데이터가 캐시에 남아있을 위험을 방지하는 중요한 설정이다.

---