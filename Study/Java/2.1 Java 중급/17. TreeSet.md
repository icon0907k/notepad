`TreeSet`은 Java의 `java.util` 패키지에 속하는 클래스 중 하나로, `Set` 인터페이스를 구현한다. 이 클래스는 요소의 중복을 허용하지 않으며 이진 검색 트리(레드-블랙 트리)를 기반으로 데이터를 저장한다. `TreeSet`은 정렬된 집합 자료구조로 요소를 자동으로 정렬하여 저장한다.

## 1. 주요 특징
1. **중복 허용 안 함** : `TreeSet`은 동일한 요소를 두 번 추가할 수 없다. 같은 값을 갖는 두 개의 요소는 존재할 수 없다.
2. **정렬 유지** : `TreeSet`은 요소를 정렬된 순서로 저장한다. 기본적으로 요소의 자연 순서에 따라 정렬되며, 사용자 정의 정렬 기준을 제공할 수도 있다.
3. **이진 검색 트리 기반** : 내부적으로 이진 검색 트리(레드-블랙 트리)를 사용하여 요소를 저장한다. 이로 인해 요소의 추가, 삭제, 검색 작업이 효율적으로 수행된다.
4. **성능** : 요소의 추가, 삭제, 검색 작업은 O(log n)의 시간 복잡도로 수행된다. 이는 트리 구조의 특성 때문이다.
5. **null 값 허용 안 함**: `TreeSet`은 null 값을 저장할 수 없다. null을 추가하면 `NullPointerException`이 발생한다.

## 2. 주요 메서드

| 메서드                  | 설명                          |
| -------------------- | --------------------------- |
| `add(E e)`           | 지정된 요소를 세트에 추가한다.           |
| `remove(Object o)`   | 지정된 요소를 세트에서 제거한다.          |
| `contains(Object o)` | 세트가 지정된 요소를 포함하는지 여부를 반환한다. |
| `size()`             | 세트에 있는 요소의 수를 반환한다.         |
| `isEmpty()`          | 세트가 비어 있는지 여부를 반환한다.        |
| `clear()`            | 세트의 모든 요소를 제거한다.            |
| `iterator()`         | 세트의 요소에 대한 반복자를 반환한다,.      |
| `toArray()`          | 세트의 모든 요소를 배열로 반환한다.        |

## 3. 성능

- **시간 복잡도**:
    - 데이터 추가: O(log n)
    - 데이터 삭제: O(log n)
    - 데이터 검색: O(log n)
    - 데이터 존재 여부 확인: O(log n)
- **메모리**: `TreeSet`은 이진 검색 트리 구조를 사용하여 요소를 저장한다. 이 트리 구조는 각 노드가 포인터를 사용하므로 메모리 사용량이 증가할 수 있다. 요소의 수가 많아질수록 트리의 높이가 증가하며 이에 따라 메모리 사용량도 증가한다.
    
### 성능 이해하기
16개의 데이터를 가진 경우 단 4번의 비교 만으로 최종 노드에 도달할 수 있다. 다음은 이진 검색 트리에서 데이터 개수에 따른 비교 횟수를 정리한 것이다
- 2개의 데이터: `log₂(2) = 1` (1번 나누기)
- 4개의 데이터: `log₂(4) = 2` (2번 나누기)
- 8개의 데이터: `log₂(8) = 3` (3번 나누기)
- 16개의 데이터: `log₂(16) = 4` (4번 나누기)
- 32개의 데이터: `log₂(32) = 5` (5번 나누기)
- 64개의 데이터: `log₂(64) = 6` (6번 나누기)
- ...
- 1024개의 데이터: `log₂(1024) = 10` (10번 나누기)

즉, 1024개의 데이터를 단 10번의 비교로 원하는 결과를 찾을 수 있다. 데이터의 크기가 증가해도, 매번 계산을 통해 절반을 제거할 수 있으므로 O(n)과 비교했을 때, 데이터의 크기가 커질수록 성능이 더욱 효과적이다.

이러한 성능을 수학적으로 표현하면 `log₂(n)`이 되며 이는 쉽게 말해 2로 몇 번 나누어서 1에 도달하는지를 계산하는 것이다. 빅오 표기법에서는 상수를 사용하지 않으므로, 이를 간단히 `O(log n)`으로 표현한다.

## 4. 사용 예시
``` java
import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        TreeSet<String> fruits = new TreeSet<>();
        // 요소 추가
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Apple1");
        // 요소 포함 여부 확인
        System.out.println(fruits.contains("Banana")); // true
        // 크기 확인
        System.out.println("Size: " + fruits.size()); // 3
        // 요소 제거
        fruits.remove("Apple1");
        // 모든 요소 출력 (정렬된 순서로 출력)
        for (String fruit : fruits) {
            System.out.println(fruit);
        }
        // 비어 있는지 확인
        System.out.println("비어 있니? " + fruits.isEmpty()); // false
        // 모든 요소 제거
        fruits.clear();
        System.out.println("size: " + fruits.size()); // 0
    }
}
```

## 5. TreeSet 저장 방식

 **이진 검색 트리 기본 구조**
1. 왼쪽 자식 노드는 부모 노드보다 작다.
2. 오른쪽 자식 노드는 부모 노드보다 크다.
3. 각 노드는 최대 두 개의 자식을 가질 수 있다.

예시 : 이진 검색 트리 구성
아래의 숫자들을 차례대로 추가해 보겠습니다: `20`, `15`, `25`, `10`, `5`.

 1단계: 20 추가
```css
    [20]
```
2단계: 15 추가
```css
      [20]
     /
   [15]
```
3단계: 25 추가
``` css
      [20]
     /    \
   [15]  [25]
```
4단계: 10 추가
``` css
      [20]
     /    \
   [15]  [25]
   /
 [10]
```
5단계: 5 추가
``` css
      [20]
     /    \
   [15]  [25]
   /
 [10]
 /
[5]
```
 **이진 검색 트리의 검색, 삽입, 삭제**
- **검색** : 노드를 찾을 때는 현재 노드의 값과 비교하여 왼쪽 또는 오른쪽 자식으로 이동한다.
- **삽입** : 새로운 노드를 추가할 때도 검색과 동일한 방식으로 진행하며, 적절한 위치를 찾아 추가한다.
- **삭제** : 삭제할 노드의 자식 수에 따라 세 가지 경우로 나뉘어 처리한다.
    1. **리프 노드(자식 노드가 없는 노드)**: 그냥 삭제.
    2. **자식이 하나인 노드**: 해당 노드를 삭제하고 그 자식을 대체.
    3. **자식이 두 개인 노드**: 대체할 노드를 찾아 삭제.

 예시 : 노드 삭제

예를 들어, `15`를 삭제한다고 가정해보자. 삭제 후 노드는 다음과 같이 변한다.
1. 삭제 전
```css
      [20]
     /    \
   [15]  [25]
   /
 [10]
 /
[5]
```

2. - `15`가 삭제되면 `10`이 대체 노드가 되어 트리는 다음과 같이 변한다.
``` CSS
      [20]
     /    \
   [10]  [25]
   /
 [5]

```
## 6. 주의사항

- **쓰레드 안전성**: `TreeSet`은 기본적으로 쓰레드 안전하지 않아서 여러 쓰레드가 동시에 접근할 경우 데이터 무결성을 보장하기 위해 `Collections.synchronizedSet()` 또는 `ConcurrentSkipListSet`과 같은 방법을 사용해야 한다.
- **초기 용량**: `TreeSet`은 초기 용량을 명시적으로 설정할 수 없지만 기본적으로 트리 구조에서 요소를 추가하면서 자동으로 크기가 조정된다. 성능을 최적화하기 위해 예상되는 요소 개수를 고려하여 적절한 초기 용량을 설정하는 것이 좋다.

요약
`TreeSet`은 중복된 데이터를 저장하지 않고 자동으로 정렬된 상태를 유지하는 특성이 있다. 고유한 데이터의 정렬된 집합을 필요로 하는 경우에 유용하게 사용된다. 특정 데이터의 정렬된 목록이 필요할 때 효과적이다.