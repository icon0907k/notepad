`TreeMap`은 Java의 `java.util` 패키지에 속하는 클래스 중 하나로 `Map` 인터페이스를 구현한다. 이 클래스는 키-값 쌍을 저장하며, 키의 중복을 허용하지 않는다. 내부적으로 이진 검색 트리(레드-블랙 트리)를 기반으로 데이터를 저장하며 키를 자동으로 정렬하여 관리한다.

## 1. 주요 특징
1. **키 중복 허용 안 함** : `TreeMap`은 동일한 키를 두 번 추가할 수 없다. 같은 키를 갖는 두 개의 항목은 존재할 수 없다.
2. **정렬 유지** : `TreeMap`은 키를 정렬된 순서로 저장한다. 기본적으로 키의 자연 순서에 따라 정렬되며 사용자 정의 정렬 기준을 제공할 수도 있다.
3. **이진 검색 트리 기반** : 내부적으로 이진 검색 트리(레드-블랙 트리)를 사용하여 키-값 쌍을 저장한다. 이로 인해 키의 추가, 삭제, 검색 작업이 효율적으로 수행된다.
4. **성능** : 키의 추가, 삭제, 검색 작업은 O(log n)의 시간 복잡도로 수행된다. 이는 트리 구조의 특성 때문이다.
5. **null 키 허용 안 함** : `TreeMap`은 null 키를 저장할 수 없다. null 키를 추가하면 `NullPointerException`이 발생한다. 그러나 null 값은 저장할 수 있다.

## 2. 주요 메서드

| 메서드                       | 설명                                          |
| ------------------------- | ------------------------------------------- |
| `put(K key, V value)`     | 지정된 키와 값을 맵에 추가한다.                          |
| `remove(Object key)`      | 지정된 키를 가진 항목을 맵에서 제거한다.                     |
| `get(Object key)`         | 지정된 키에 대한 값을 반환합니다. 키가 존재하지 않으면 null을 반환한다. |
| `containsKey(Object key)` | 맵이 지정된 키를 포함하는지 여부를 반환한다.                   |
| `size()`                  | 맵에 있는 항목의 수를 반환한다.                          |
| `isEmpty()`               | 맵이 비어 있는지 여부를 반환한다.                         |
| `clear()`                 | 맵의 모든 항목을 제거한다.                             |
| `keySet()`                | 맵의 모든 키를 포함하는 집합을 반환한다.                     |
| `values()`                | 맵의 모든 값을 포함하는 컬렉션을 반환한다.                    |
| `entrySet()`              | 맵의 모든 엔트리를 포함하는 집합을 반환한다.                   |

## 3. 성능

- **시간 복잡도** :
    - 키 추가: O(log n)
    - 키 삭제: O(log n)
    - 키 검색: O(log n)
    - 키 존재 여부 확인: O(log n)
- **메모리** : `TreeMap`은 이진 검색 트리 구조를 사용하여 키-값 쌍을 저장한다. 이 트리 구조는 각 노드가 포인터를 사용하므로 메모리 사용량이 증가할 수 있다. 키의 수가 많아질수록 트리의 높이가 증가하며 이에 따라 메모리 사용량도 증가한다.

### 성능 이해하기

16개의 키-값 쌍이 있는 경우 단 4번의 비교 만으로 최종 노드에 도달할 수 있다. 다음은 이진 검색 트리에서 키 개수에 따른 비교 횟수를 정리한 것이다
- 2개의 키: `log₂(2) = 1` (1번 나누기)
- 4개의 키: `log₂(4) = 2` (2번 나누기)
- 8개의 키: `log₂(8) = 3` (3번 나누기)
- 16개의 키: `log₂(16) = 4` (4번 나누기)
- 32개의 키: `log₂(32) = 5` (5번 나누기)
- 64개의 키: `log₂(64) = 6` (6번 나누기)
- ...
- 1024개의 키: `log₂(1024) = 10` (10번 나누기)
즉, 1024개의 키-값 쌍을 단 10번의 비교로 원하는 결과를 찾을 수 있다. 데이터의 크기가 증가해도 매번 계산을 통해 절반을 제거할 수 있으므로 O(n)과 비교했을 때, 데이터의 크기가 커질수록 성능이 더욱 효과적이다.

이러한 성능을 수학적으로 표현하면 `log₂(n)`이 되며 이는 쉽게 말해 2로 몇 번 나누어서 1에 도달하는지를 계산하는 것이다. 빅오 표기법에서는 상수를 사용하지 않으므로, 이를 간단히 `O(log n)`으로 표현한다.

## 4. 사용 예시
```java
import java.util.TreeMap;

public class TreeMapExample {
    public static void main(String[] args) {
        TreeMap<String, Integer> fruitPrices = new TreeMap<>();
        // 키-값 쌍 추가
        fruitPrices.put("Apple", 100);
        fruitPrices.put("Banana", 50);
        fruitPrices.put("Apple1", 150);
        // 키 포함 여부 확인
        System.out.println(fruitPrices.containsKey("Banana")); // true
        // 크기 확인
        System.out.println("Size: " + fruitPrices.size()); // 3
        // 특정 키의 값 가져오기
        System.out.println("Apple 값: " + fruitPrices.get("Apple")); // 100
        // 모든 키 출력 (정렬된 순서로 출력)
        for (String fruit : fruitPrices.keySet()) {
            System.out.println(fruit + ": " + fruitPrices.get(fruit));
        }
        // 특정 키 제거
        fruitPrices.remove("Banana");
        // 비어 있는지 확인
        System.out.println("비어 있니? " + fruitPrices.isEmpty()); // false
        // 모든 항목 제거
        fruitPrices.clear();
        System.out.println("size: " + fruitPrices.size()); // 0
    }
}
```
## 5. TreeMap 저장 방식

 **이진 검색 트리 기본 구조**
1. 왼쪽 자식 노드는 부모 노드보다 작다.
2. 오른쪽 자식 노드는 부모 노드보다 크다.
3. 각 노드는 최대 두 개의 자식을 가질 수 있다.

예시 : 이진 검색 트리 구성
아래의 숫자들을 차례대로 추가해 보겠습니다: `20`, `15`, `25`, `10`, `5`.

 1단계: 20 추가
```css
    [20]
```
2단계: 15 추가
```css
      [20]
     /
   [15]
```
3단계: 25 추가
``` css
      [20]
     /    \
   [15]  [25]
```
4단계: 10 추가
``` css
      [20]
     /    \
   [15]  [25]
   /
 [10]
```
5단계: 5 추가
``` css
      [20]
     /    \
   [15]  [25]
   /
 [10]
 /
[5]
```
 **이진 검색 트리의 검색, 삽입, 삭제**
- **검색** : 노드를 찾을 때는 현재 노드의 값과 비교하여 왼쪽 또는 오른쪽 자식으로 이동한다.
- **삽입** : 새로운 노드를 추가할 때도 검색과 동일한 방식으로 진행하며, 적절한 위치를 찾아 추가한다.
- **삭제** : 삭제할 노드의 자식 수에 따라 세 가지 경우로 나뉘어 처리한다.
    1. **리프 노드(자식 노드가 없는 노드)**: 그냥 삭제.
    2. **자식이 하나인 노드**: 해당 노드를 삭제하고 그 자식을 대체.
    3. **자식이 두 개인 노드**: 대체할 노드를 찾아 삭제.

 예시 : 노드 삭제

예를 들어, `15`를 삭제한다고 가정해보자. 삭제 후 노드는 다음과 같이 변한다.
1. 삭제 전
```css
      [20]
     /    \
   [15]  [25]
   /
 [10]
 /
[5]
```

2. - `15`가 삭제되면 `10`이 대체 노드가 되어 트리는 다음과 같이 변한다.
``` CSS
      [20]
     /    \
   [10]  [25]
   /
 [5]
 ```
 
 ## 6. 주의사항
- **쓰레드 안전성** : `TreeMap`은 기본적으로 쓰레드 안전하지 않아서 여러 쓰레드가 동시에 접근할 경우 데이터 무결성을 보장하기 위해 `Collections.synchronizedMap()` 또는 `ConcurrentSkipListMap`과 같은 방법을 사용해야 한다.
- **초기 용량** : `TreeMap`은 초기 용량을 명시적으로 설정할 수 없지만 기본적으로 트리 구조에서 요소를 추가하면서 자동으로 크기가 조정된다. 성능을 최적화하기 위해 예상되는 키의 개수를 고려하여 적절한 초기 용량을 설정하는 것이 좋다.
- **비교기**: 사용자 정의 정렬이 필요한 경우 `Comparator`를 제공하여 특정 기준으로 정렬할 수 있다.

이와 같은 `TreeMap`의 특성을 이해하고 적절하게 활용하면 효율적으로 키-값 쌍을 관리할 수 있다.
