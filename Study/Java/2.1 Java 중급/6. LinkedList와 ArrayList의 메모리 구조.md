### LinkedList 메모리 구조
- **구조** : LinkedList는 각 노드가 데이터와 다음 노드를 가리키는 포인터로 구성된다. 이로 인해 노드가 메모리에서 불연속적으로 저장될 수 있다.
``` css
[데이터 | 다음] -> [데이터 | 다음] -> [데이터 | 다음] -> null
```
**특징** 
    1. **동적 크기 조절** : 요소를 추가하거나 제거할 때 메모리를 재할당할 필요가 없다.
    2. **삽입 및 삭제** : O(1) 시간 복잡도로 수행할 수 있다. 노드의 포인터만 변경하면 되기 때문이다.
    3. **메모리 오버헤드** : 각 노드에 포인터를 저장해야 하므로 추가적인 메모리를 사용한다.

### ArrayList 메모리 구조
- **구조** : ArrayList는 내부적으로 동적 배열을 사용한다. 배열은 연속적인 메모리 공간에 저장된다.
``` css
[데이터][데이터][데이터][null][null]
```
 **특징** 
    1. **고정 크기** : 배열의 크기는 초기화 시 정해지며 크기를 초과하면 새로운 배열을 생성하고 기존 요소를 복사해야 한다.
    2. **읽기 성능** : O(1) 시간 복잡도로 요소에 접근할 수 있다. 배열 인덱스를 통해 직접 접근하기 때문이다.
    3. **삽입 및 삭제** : 중간에 요소를 추가하거나 제거할 경우 O(n) 시간 복잡도가 필요하다. 요소를 이동해야 하므로 비효율적이다.

### 비유
- **LinkedList**: 마치 여러 개의 컨테이너(노드)가 줄지어 있는 형태입니다. 각 컨테이너는 다음 컨테이너를 가리키며 원하는 컨테이너에 쉽게 접근할 수 있지만  특정 위치에 컨테이너를 추가하거나 제거하는 것은 간편하다.
    
- **ArrayList**: 여러 개의 상자가 연속적으로 배열된 형태입니다. 상자는 정해진 크기를 가지고 있으며, 특정 상자에 빠르게 접근할 수 있지만, 중간의 상자를 변경하려면 모든 상자를 이동해야 한다.