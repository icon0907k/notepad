### LinkedList 메모리 구조
- **구조** : 이중 연결 리스트는 각 노드가 데이터와 함께 두 개의 포인터를 가지고 있다. 하나는 다음 노드에 대한 포인터 다른 하나는 이전 노드에 대한 포인터이다. 이를 통해 양방향으로 탐색이 가능한다.
``` css
null <- [이전 | 데이터 | 다음] <-> [이전 | 데이터 | 다음] <-> [이전 | 데이터 | 다음] -> null
```
**특징** 
	1. **동적 크기 조절** : 요소를 추가하거나 제거할 때 메모리를 재할당할 필요가 없다.
	2. **삽입 및 삭제** : 노드의 포인터만 변경하면 되기 때문에 O(1) 시간 복잡도로 수행할 수 있다. 특히, 이전 노드와 다음 노드 모두에 접근할 수 있어 삽입 및 삭제가 유리하다.
	3. **양방향 탐색**: 이전 노드와 다음 노드에 모두 접근할 수 있으므로 양방향으로 리스트를 탐색할 수 있다.
	4. **메모리 오버헤드**: 각 노드에 이전 노드와 다음 노드를 가리키는 두 개의 포인터가 필요하므로, 추가적인 메모리를 사용한다. 따라서 단일 연결 리스트에 비해 메모리 사용량이 더 많다.

### ArrayList 메모리 구조
- **구조** : ArrayList는 내부적으로 동적 배열을 사용한다. 배열은 연속적인 메모리 공간에 저장된다.
``` css
[데이터][데이터][데이터][null][null]
```
 **특징** 
    1. **고정 크기** : 배열의 크기는 초기화 시 정해지며 크기를 초과하면 새로운 배열을 생성하고 기존 요소를 복사해야 한다.
    2. **읽기 성능** : O(1) 시간 복잡도로 요소에 접근할 수 있다. 배열 인덱스를 통해 직접 접근하기 때문이다.
    3. **삽입 및 삭제** : 중간에 요소를 추가하거나 제거할 경우 O(n) 시간 복잡도가 필요하다. 요소를 이동해야 하므로 비효율적이다.

### 비유
- **LinkedList**: 마치 여러 개의 컨테이너(노드)가 줄지어 있는 형태이다. 각 컨테이너는 다음 컨테이너를 가리키며 원하는 컨테이너에 쉽게 접근할 수 있지만  특정 위치에 컨테이너를 추가하거나 제거하는 것은 간편하다.
    
- **ArrayList**: 여러 개의 상자가 연속적으로 배열된 형태이다. 상자는 정해진 크기를 가지고 있으며, 특정 상자에 빠르게 접근할 수 있지만, 중간의 상자를 변경하려면 모든 상자를 이동해야 한다.