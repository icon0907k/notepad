[[11. volatile과 메모리 가시성 이해하기]] 이어서
## CPU와 메모리 구조
현대 CPU는 처리 성능을 높이기 위해 **캐시 메모리**를 활용한다. 메인 메모리는 CPU에 비해 상대적으로 멀고 속도가 느리기 때문에 CPU는 빠른 연산을 수행하기 위해 가까운 위치에 있는 캐시 메모리를 사용한다. 캐시 메모리는 속도가 매우 빠르지만 용량이 제한적이다. 이로 인해, CPU는 각 코어마다 캐시 메모리를 보유하거나 여러 코어가 공유하는 캐시 메모리를 사용할 수 있다.

## 스레드와 메모리 가시성
자바의 멀티스레드 환경에서 스레드가 `runFlag`라는 변수를 사용하는 경우, CPU는 이 변수를 효율적으로 처리하기 위해 먼저 캐시 메모리에 불러온다. 모든 스레드는 자신만의 캐시 메모리에서 `runFlag`의 값을 읽고 사용하게 된다. 초기에는 `runFlag`가 `true`로 설정되어 있어 모든 스레드가 이 값을 참조하며 작업을 수행한다.

1. **변경 시점** : `main` 스레드는 1초 후에 `runFlag` 값을 `false`로 변경한다.
2. **캐시 메모리의 변화** : 이때 `main` 스레드의 캐시 메모리에 있는 `runFlag` 값은 `false`로 변경된다. 그러나 **중요한 점은** 메인 메모리에는 이 변경이 즉시 반영되지 않는다는 것이다. `main` 스레드의 캐시 메모리에서만 값이 변경되므로, `work` 스레드는 여전히 자신의 캐시 메모리에서 `true` 값을 참조하게 된다.

## 메모리 가시성의 원인
캐시 메모리의 `runFlag` 값만 변하므로, `work` 스레드는 여전히 `true` 상태를 유지하며 루프를 반복한다. 메인 메모리에 변경된 `runFlag` 값이 언제 CPU 코어의 캐시 메모리에 반영될지는 확실하지 않는다. 이로 인해 **메모리 가시성(memory visibility)** 문제가 발생한다. 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지를 나타내는 개념이다.

- **불확실한 시점** : 메인 메모리에 반영되더라도 다시 캐시 메모리에 업데이트되는 시점은 CPU의 설계 방식과 실행 환경에 따라 다르다. 캐시 메모리의 값을 언제 메인 메모리에 반영하거나, 메인 메모리의 변경 내역을 캐시 메모리로 불러오는지는 예측할 수 없다.

## `volatile` 키워드
`volatile`는 자바에서 변수의 메모리 가시성을 보장하기 위해 사용되는 예약어이다. 이 키워드는 멀티스레드 환경에서 한 스레드가 변경한 변수의 값이 다른 스레드에서 즉시 반영되도록 한다.

1. **메모리 가시성 보장**
    - `volatile`로 선언된 변수는 메인 메모리와 각 스레드의 캐시 메모리 간의 동기화를 보장한다.
    - 한 스레드가 `volatile` 변수를 수정하면, 그 변경 사항이 즉시 다른 모든 스레드에 반영된다.
2. **CPU 캐시 사용**
    - `volatile` 변수가 선언된 경우, JVM은 해당 변수를 **메인 메모리에서 읽고 쓰도록 강제**한다.
    - 따라서 스레드는 `volatile` 변수를 읽을 때마다 메인 메모리에서 최신 값을 가져오고, 값을 쓸 때도 메인 메모리에 직접 반영한다.
3. **가시성 확보**
    - 일반 변수는 각 스레드의 캐시 메모리에 복사되어 사용되므로 한 스레드에서 변경한 값이 다른 스레드에서 즉시 보이지 않을 수 있다.
    - 그러나 `volatile`로 선언된 변수는 이러한 문제가 발생하지 않으며 모든 스레드가 동일한 값을 공유할 수 있다.
## 결론
멀티스레드 환경에서는 각 스레드가 독립적으로 캐시 메모리를 사용하게 되므로, 한 스레드에서 변경된 값이 다른 스레드에 즉시 반영되지 않는다. 이를 해결하기 위해 `volatile` 키워드를 사용하여 변수를 선언하면, 변수의 변경 사항이 모든 스레드에 즉시 반영되도록 보장할 수 있다.

**메모리 가시성을 확보하려면 `volatile`을 사용하여 스레드 간의 일관성을 유지해야 한다.**