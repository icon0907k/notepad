원자적 연산(Atomic Operation)은 더 이상 쪼갤 수 없는 하나의 단위 작업으로, 한 번에 하나의 작업이 완료되며 작업이 완료되기 전까지 다른 스레드가 그 작업을 방해할 수 없는 상태를 보장한다. 이는 **동시성 프로그래밍**에서 매우 중요한 개념이다. 여러 스레드가 동시에 자원에 접근할 때 데이터 무결성을 보장하기 위해 사용된다.

---
## 원자적 연산의 특징

1. **불가분성(Indivisibility)** : 작업은 중단되지 않고 한 번에 완료된다. 작업이 중간에 중단되거나 나누어지지 않고 단일 작업으로 수행된다.
2. **동시성 보장** : 여러 스레드가 동시에 접근하더라도 작업이 중간에 방해받거나 다른 스레드에 의해 변경되지 않는다.
3. **일관성 유지** : 원자적 연산이 실행되면 그 결과는 항상 일관되고 정확하게 유지돈다. 작업 도중에 데이터가 중간 상태에 머무르지 않는다.

---
## 원자적 연산의 예시
만약 두 개의 스레드가 같은 공유 변수 `count`에 접근하여 동시에 `count++` 연산을 수행하려고 할 때 발생할 수 있는 문제를 생각해보자.
```java
int count = 0;

// 두 스레드에서 동시에 아래 연산을 시도:
count++;
```
`count++`는 사실 **세 단계**로 이루어진다

1. 현재 `count` 값을 읽음
2. 그 값을 1 증가시킴
3. 증가된 값을 다시 `count`에 저장

두 스레드가 동시에 이 작업을 실행하면, 두 스레드 모두 `count = 0` 값을 읽고 각각 1을 증가시킨 후 `count`에 다시 저장하려고 한다. 결국 `count`는 2가 아닌 1이 되어버린다. 이는 **경쟁 상태**(Race Condition)로 인해 발생하는 문제이다.

---
## CAS(Compare-And-Swap)의 역할
이런 문제를 해결하기 위해 CAS(Compare-And-Swap)가 사용된다. CAS는 **동시성 문제를 해결하는 대표적인 원자적 연산 기법**이다.

CAS의 기본 개념
- **기대 값(Expect Value)** : 스레드가 예상하는 현재 값
- **현재 값(Current Value)** : 메모리에 저장된 실제 값
- **새로운 값(New Value)** : 업데이트하려는 값

CAS는 메모리에 있는 **현재 값**을 **기대 값**과 비교한 후
- 두 값이 같으면 **새로운 값**으로 교체한다.
- 값이 다르면 작업을 실패 처리하고, 아무런 변경도 이루어지지 않는다.

CAS는 여러 스레드가 동시에 값을 변경할 때 **락을 사용하지 않고도 안전하게** 처리할 수 있다. Java에서는 `Atomic` 클래스들이 내부적으로 CAS 연산을 사용하여 안전한 동시성 제어를 제공한다.
### CAS 장점과 단점
#### **장점**
1. **낙관적 동기화** : 락 없이 안전하게 값을 업데이트할 수 있으며, 충돌이 적은 환경에서 높은 성능을 발휘.
2. **락 프리(Lock-Free)** : 락을 사용하지 않아 대기 시간이 없고, 스레드가 블로킹되지 않음.
#### **단점**
1. **빈번한 충돌** : 여러 스레드가 동시에 접근 시 충돌이 발생, 이때 재시도로 CPU 자원 소모.
2. **오버헤드** : 충돌 시 반복 재시도가 발생, 스핀락과 유사한 성능 저하 초래.

### 동기화 락
#### **장점**
1. **충돌 관리** : 하나의 스레드만 리소스에 접근, 안정적인 동작 보장.
2. **안정성** : 복잡한 상황에서도 일관된 동작 유지.
3. **스레드 대기** : 락 대기 시 CPU 사용량 감소.
#### **단점**
1. **대기 시간** : 락 획득을 위한 대기 시간이 길어질 수 있음.
2. **오버헤드** : 락 획득 시 컨텍스트 스위칭 발생, 성능 저하.

---
### Java에서 원자적 연산과 CAS 사용

Java에서는 `java.util.concurrent.atomic` 패키지를 통해 **원자적 클래스**들을 제공한다. 예를 들어, `AtomicInteger`는 내부적으로 CAS를 사용해 값을 원자적으로 처리한다.

#### `AtomicInteger`를 사용한 예제

**AtomicInteger 메소드** 
- `new AtomicInteger(0)` : 초기값을 지정한다. 생략하면 `0` 부터 시작한다.
- `incrementAndGet()` : 값을 하나 증가하고 증가된 결과를 반환한다.
- `get()` : 현재 값을 반환한다.
```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicExample {
    private static final AtomicInteger count = new AtomicInteger(0);
    
    public static void main(String[] args) throws InterruptedException {
        // 1000번씩 증가하는 스레드 두 개를 만듦
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                count.incrementAndGet();  // 원자적 연산
            }
        });
        
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                count.incrementAndGet();  // 원자적 연산
            }
        });
        
        t1.start();
        t2.start();
        
        t1.join();
        t2.join();
        
        // 두 스레드가 완료된 후 출력
        System.out.println("최종 카운트 값: " + count);
    }
}
```
### 코드 설명 :
1. **`AtomicInteger`**: `AtomicInteger` 클래스는 원자적으로 정수값을 처리하는 기능을 제공한다. `incrementAndGet()` 메서드는 **한 번에 증가하고 값을 반환하는 작업**이 하나의 원자적 연산으로 수행된다.
2. **`incrementAndGet()`**: `count++`와 같은 증가 연산을 원자적으로 처리한다. 여러 스레드가 동시에 이 메서드를 호출하더라도 경쟁 상태 없이 정확한 값이 반환된다.

### 실행 결과 
위 예제에서 두 스레드가 각각 1000번씩 값을 증가시키므로, 최종 `count` 값은 **2000**이 되어야 한다. 이 값은 `AtomicInteger` 덕분에 정확하게 계산된다.

### 원자적 연산이 필요한 이유
1. **동시성 제어** : 여러 스레드가 같은 데이터에 동시에 접근할 때 경합 조건이 발생할 수 있다. 원자적 연산을 사용하면 이런 문제를 방지할 수 있다.
2. **데이터 무결성** : 동시성 문제로 인해 데이터가 손상되거나 불일치가 발생하는 것을 막아준다.
3. **간결하고 안전한 코드** : `Atomic` 클래스들을 사용하면 명시적인 락(lock)을 걸 필요 없이 스레드 안전하게 코드를 작성할 수 있다.

### 대표적인 원자적 클래스
Java에서는 다양한 `Atomic` 클래스를 제공하여 기본 타입들에 대한 원자적 연산을 지원한다.
- `AtomicInteger`: 원자적으로 정수를 다룸
- `AtomicLong`: 원자적으로 `long` 값을 다룸
- `AtomicBoolean`: 원자적으로 `boolean` 값을 다룸
- `AtomicReference<T>`: 객체에 대한 참조를 원자적으로 다룸
### 요약
- **원자적 연산**은 더 이상 나눌 수 없는 단일 작업으로, 중단되지 않고 한 번에 완료되며, 동시성 문제를 해결한다.
- **CAS(Compare-And-Swap)**는 **기대 값**과 **현재 값**을 비교하여, 값이 일치할 때만 **새로운 값**으로 교체하는 방식으로, 락 없이도 여러 스레드가 데이터를 안전하게 수정할 수 있다.
- Java에서는 `AtomicInteger`와 같은 **Atomic 클래스**들을 통해 원자적 연산과 CAS를 쉽게 구현할 수 있다.