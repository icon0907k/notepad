## 스레드를 직접 사용할 때의 문제점
스레드는 멀티스레딩 프로그래밍에서 중요한 역할을 하지만, 직접 생성하고 관리할 때 여러 가지 문제점이 발생한다. 다음은 스레드를 직접 사용할 때의 주요 문제점과 그 해결책에 대한 내용이다.
### 1. 스레드 생성 비용으로 인한 성능 문제
스레드를 생성하는 것은 단순히 객체를 생성하는 것보다 훨씬 더 무거운 작업이다. 
- **메모리 할당** : 각 스레드는 자신만의 호출 스택을 가지고 있어야 하며 이 호출 스택은 메모리 공간을 차지한다. 따라서 스레드가 생성될 때마다 해당 메모리를 할당해야 한다.
    
- **운영체제 자원 사용** : 스레드 생성 작업은 운영체제 커널에서 이루어지며, 시스템 콜을 통해 처리된다. 이 과정은 CPU와 메모리 리소스를 소모하게 된다.
    
- **운영체제 스케줄러 설정** : 새로운 스레드가 생성되면 운영체제의 스케줄러가 이를 관리하고 실행 순서를 조정해야 한다. 이로 인해 추가적인 오버헤드가 발생할 수 있다.
    
특정 작업을 수행할 때마다 새로운 스레드를 생성한다면 스레드 생성에 소모되는 시간 때문에 실제 작업 시간이 더 길어질 수 있다. 이러한 문제를 해결하기 위해 스레드를 재사용하는 방법을 고려해야 한다. 재사용함으로써 초기 생성 비용을 제외하고는 추가적인 생성 시간이 필요 없어진다.
### 2. 스레드 관리 문제
서버의 CPU와 메모리 자원은 한정되어 있어 스레드를 무한정 생성할 수 없다. 예를 들어 사용자 주문을 처리하는 서비스에서 스레드를 매번 생성한다면 갑자기 수천 개의 주문이 몰릴 경우 시스템이 감당할 수 없는 상황이 발생할 수 있다. 이를 해결하기 위해서는 시스템이 견딜 수 있는 최대 스레드 수를 설정하고 그 수치 내에서 스레드를 생성 및 관리해야 한다. 또한 애플리케이션을 안전하게 종료하기 위해서는 실행 중인 스레드가 남은 작업을 수행하도록 해야 하며 필요할 경우 인터럽트를 통해 급하게 종료할 수 있는 관리 체계가 필요하다.
### 3. `Runnable` 인터페이스의 불편함
```java
public interface Runnable {
    void run();
}
```
- **반환 값이 없다** : `run()` 메서드는 반환 값을 가지지 않기 때문에 실행 결과를 얻기 위해 별도의 메커니즘을 사용해야 한다. 멤버 변수에 결과를 저장한 후, `join()`을 호출하여 스레드가 종료될 때까지 기다려야 한다.
    
- **예외 처리** : `run()` 메서드는 체크 예외를 던질 수 없으며, 이로 인해 메서드 내부에서 예외 처리를 직접 수행해야 하는 번거로움이 있다.
    

### 해결책 : 스레드 풀
이러한 문제들을 해결하기 위해 스레드 풀의 개념을 도입할 수 있다. 스레드 풀은 미리 필요한 만큼의 스레드를 생성하여 대기시킨다. 작업 요청이 들어오면 대기 중인 스레드를 활용하여 작업을 처리하고 작업이 완료된 후 다시 스레드 풀에 반납된다. 이렇게 하면 스레드를 재사용할 수 있어 생성 비용을 절감하고 필요한 만큼의 스레드만을 관리할 수 있다.

스레드 풀은 단순히 컬렉션에 스레드를 보관하는 것이 아니라 처리할 작업이 없는 스레드는 대기 상태로 유지해야 하며 요청이 오면 실행 가능한 상태로 전환해야 한다. 이를 구현하는 것은 쉽지 않으며 생산자-소비자 문제와 같은 추가적인 복잡성이 따른다.

이런 복잡한 문제를 해결해주는 것이 자바의 **Executor 프레임워크**이다. 이 프레임워크는 스레드 풀 관리, 스레드 생성 및 `Runnable`의 문제점 그리고 생산자-소비자 문제까지 한 번에 해결해주는 매우 유용한 도구이다. 실무에서는 이러한 프레임워크를 활용해 보다 효율적으로 멀티스레드 프로그래밍을 할 수 있다.

결론적으로 스레드를 직접 생성하여 사용하는 것보다는 Executor 프레임워크와 같은 도구를 활용하는 것이 훨씬 더 효과적이며 실용적인 접근 방식이다.