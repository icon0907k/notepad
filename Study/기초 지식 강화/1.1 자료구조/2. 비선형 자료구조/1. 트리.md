트리는 계층적 구조를 표현하는 데 사용되는 비선형 자료구조이다. 노드(Node)들 간의 부모-자식 관계를 통해 데이터를 구조화하며 다양한 응용 분야에서 중요한 역할을 한다.

**트리의 기본 개념**
1. 노드(Node) : 트리의 기본 구성 단위로 데이터를 저장하며 다른 노드와 연결된다.
2. 루트 노드(Root Node) : 트리의 최상위에 위치한 노드로 모든 노드의 조상이다.
3. 자식 노드(Child Node) : 특정 노드 아래에 위치한 하위 노드이다.
4. 부모 노드(Parent Node) : 자식 노드를 포함하는 상위 노드이다.
5. 형제 노드(Sibling Node) : 같은 부모 노드를 공유하는 노드들이다.
6. 리프 노드(Leaf Node) : 자식 노드가 없는 노드로 트리의 끝을 나타낸다.
7. 깊이(Depth) : 루트 노드에서 특정 노드까지의 경로 길이(간선의 수)이다.
8. 높이(Height) : 특정 노드에서 가장 먼 리프 노드까지의 경로 길이이다.

 **트리의 종류**
1. 이진 트리(Binary Tree) :
    각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리이다.
        1. 포화 이진 트리(Full Binary Tree) : 모든 노드가 0개 또는 2개의 자식 노드를 가지는 트리.
        2. 완전 이진 트리(Complete Binary Tree) : 모든 레벨이 꽉 차 있으며, 마지막 레벨은 왼쪽에서 오른쪽으로 채워진 트리.
        3. 균형 이진 트리(Balanced Binary Tree) : 모든 리프 노드의 높이가 거의 같도록 유지된 트리.
        4. 이진 탐색 트리(Binary Search Tree, BST) : 왼쪽 자식 노드는 부모 노드보다 작고, 오른쪽 자식 노드는 부모 노드보다 큰 값을 가지는 트리.
2. 다진 트리(Multiway Tree) :
    각 노드가 두 개 이상(일반적으로 여러 개)의 자식 노드를 가질 수 있는 트리이다.
        1. B-트리 : 데이터베이스와 파일 시스템에서 사용되며 노드가 포화 상태가 되면 분할되는 트리 구조.
        2. B+트리 : B-트리의 변형으로 리프 노드들만 데이터를 가지고 있으며 리프 노드 간의 순차 탐색이 효율적이다.
3. AVL 트리 :
    1. 자가 균형 이진 탐색 트리의 일종으로 삽입과 삭제 후에도 트리의 균형을 유지하도록 설계되었다.
    2. 각 노드의 자식 트리 간의 높이 차이가 1을 넘지 않도록 유지한다.
4. 레드-블랙 트리(Red-Black Tree) :
    1. 또 다른 자가 균형 이진 탐색 트리로 삽입과 삭제 시 트리의 균형을 유지하는 데 약간의 느슨함을 허용하여 효율적인 성능을 제공한다.
5. 힙(Heap) :
    1. 최대값 또는 최소값을 빠르게 찾기 위해 사용되는 트리이다.
    2. 이진 힙(Binary Heap)은 우선순위 큐의 구현에 주로 사용되며, 루트 노드가 항상 최대값(또는 최소값)을 가진다.
6. 트라이(Trie) :
    1. 문자열을 효율적으로 저장하고 탐색하는 데 최적화된 트리이다.
    2. 각 노드는 문자열의 문자 또는 접두사를 나타내며, 자동완성, 사전 구현 등에 유용하다.

**트리의 순회(Tree Traversal)**
1. 전위 순회(Preorder Traversal) : 노드 → 왼쪽 자식 → 오른쪽 자식 순으로 방문.
2. 중위 순회(Inorder Traversal) : 왼쪽 자식 → 노드 → 오른쪽 자식 순으로 방문. 이진 탐색 트리에서 중위 순회는 오름차순으로 노드를 방문.
3. 후위 순회(Postorder Traversal) : 왼쪽 자식 → 오른쪽 자식 → 노드 순으로 방문.
4. 레벨 순서 순회(Level Order Traversal) : 각 레벨을 위에서 아래로, 왼쪽에서 오른쪽으로 방문. 일반적으로 큐 자료구조를 사용하여 구현

**트리의 응용**
1. 탐색(Search) : 이진 탐색 트리(BST) 등 트리 구조를 이용하여 데이터 탐색 작업을 효율적으로 수행할 수 있다. 평균적으로 O(log n)의 시간 복잡도를 가진다.
2. 정렬(Sorting) : 힙 정렬(Heap Sort)은 힙 구조를 이용한 정렬 알고리즘으로 O(n log n)의 시간 복잡도를 제공한다.
3. 계층적 데이터 표현 : 파일 시스템, 조직도, XML/HTML 문서의 DOM 구조 등에서 계층적 관계를 표현하기 위해 트리가 사용된다.
4. 경로 탐색(Pathfinding) : 그래프 알고리즘에서 최단 경로 탐색 시 트리 구조가 사용된다.
5. 데이터베이스 인덱싱 : B-트리와 B+트리는 데이터베이스의 인덱싱을 구현하는 데 사용되며 데이터 검색 속도를 향상시킨다.
6. 파일 시스템 : 파일과 디렉터리를 조직화하기 위해 트리 구조를 사용한다.
--------------------------------------------------------------------------
 **추가 정리** 
 
 1. 포화 이진 트리 (Full Binary Tree)
1. 정의 : 포화 이진 트리는 모든 노드가 0개 또는 2개의 자식 노드를 가지는 이진 트리이다. 모든 노드는 자식이 없거나 두 개의 자식 노드를 가진다.
2. 특징 :
    1. 모든 리프 노드는 동일한 깊이에 위치한다.
    2. 노드의 개수가 항상 `2^n - 1` (여기서 `n`은 트리의 높이)이다.
    3. 트리가 꽉 차 있어 각 레벨에 가능한 모든 노드가 존재(트리의 모든 층이 빈 자리 없이 가득 차 있는 상태)한다.

2. 완전 이진 트리 (Complete Binary Tree)
1. 정의 : 완전 이진 트리는 모든 레벨이 꽉 차 있으며 마지막 레벨의 노드들이 왼쪽에서 오른쪽으로 채워져 있는 이진 트리이다.
2. 특징 :
    1. 마지막 레벨을 제외한 모든 레벨이 꽉 차 있다.
    2. 마지막 레벨에서는 노드가 왼쪽부터 오른쪽 순서대로 채워진다.
    3. 노드 삽입과 삭제가 이루어질 때 완전성을 유지하도록 관리된다.
    4. 일반적으로 힙(Heap) 자료구조에서 사용된다.

3. 균형 이진 트리 (Balanced Binary Tree)
1. 정의 : 균형 이진 트리는 모든 리프 노드의 높이가 거의 같도록 유지되는 이진 트리이다. 트리의 높이가 최소화되도록 관리된다.
2. 특징 :
    1. 모든 리프 노드의 깊이 차이가 최대 1 이하로 유지됩니다.
    2. 균형을 유지함으로써 검색, 삽입, 삭제 작업이 O(log n)의 시간 복잡도를 가진다.
    3. 대표적인 균형 이진 트리로는 AVL 트리, 레드-블랙 트리 등이 있다.

4. 이진 탐색 트리 (Binary Search Tree, BST)
1. 정의 : 이진 탐색 트리는 왼쪽 자식 노드가 부모 노드보다 작고 오른쪽 자식 노드가 부모 노드보다 큰 값을 가지는 이진 트리이다.
2. 특징 :
    1. 트리의 모든 노드는 고유한 값을 가지며 중복된 값을 허용하지 않는다.
    2. 왼쪽 서브트리의 모든 값은 루트보다 작고 오른쪽 서브트리의 모든 값은 루트보다 크다.
    3. 이진 탐색 트리에서 검색, 삽입, 삭제의 시간 복잡도는 O(log n)이다. 그러나 트리가 한쪽으로 치우치게 되면 O(n)까지 증가할 수 있다.
    4. 정렬된 데이터를 이진 탐색 트리에 삽입하면 트리가 선형 구조가 될 수 있으므로 이러한 경우 균형 이진 트리로 변환하거나 트리의 균형을 유지하는 추가 작업이 필요할 수 있다.

4. AVL 트리 (AVL Tree)
1. 정의 : AVL 트리는 자가 균형 이진 탐색 트리의 한 종류로 트리에 데이터를 삽입하거나 삭제한 후에도 트리의 균형을 자동으로 유지하도록 설계된 트리이다.
2. 특징 :
    1. 균형 인수 : 각 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이를 균형 인수라고 하며, 이 값이 항상 -1, 0, 1 중 하나가 되도록 유지된다.
    2. 회전 연산 : 삽입이나 삭제로 인해 균형이 깨지면 단순 회전(왼쪽 또는 오른쪽 회전) 또는 이중 회전(왼쪽-오른쪽 회전 또는 오른쪽-왼쪽 회전)을 통해 균형을 복원한다.
    3. 시간 복잡도 : 삽입, 삭제, 탐색 작업은 O(log n)의 시간 복잡도를 가진다. 이는 트리의 높이가 log n으로 유지되기 때문에 가능한다.
    4. 응용 : 데이터베이스나 메모리 관리 시스템 등에서 널리 사용된다.

5. 레드-블랙 트리 (Red-Black Tree)
1. 정의 : 레드-블랙 트리는 또 다른 자가 균형 이진 탐색 트리로 삽입 및 삭제 시 트리의 균형을 유지하는 데 있어서 약간의 느슨함을 허용(레드-블랙 트리는 노드의 색상(빨강 또는 검정)과 몇 가지 규칙을 이용해 균형을 유지한다.  AVL 트리처럼 정확하게 높이 차이를 1로 제한하지는 않는다.  약간의 높이 차이를 허용)하여 효율적인 성능을 제공한다.
2. 특징 :
    1. 노드 색상 : 각 노드는 빨간색 또는 검은색 중 하나로 색칠되며 트리의 균형을 유지하는 규칙에 따라 노드의 색상이 조정된다.
    2. 균형 규칙 :
        1. 모든 노드는 빨간색 또는 검은색이다.
        2. 루트 노드는 항상 검은색이다.
        3. 모든 리프 노드(NIL)는 검은색이다.
        4. 빨간색 노드의 자식은 항상 검은색이다(빨간색 노드가 연속으로 나타날 수 없음).
        5. 임의의 노드에서 그 노드의 후손 리프 노드까지 가는 모든 경로에는 동일한 수의 검은색 노드가 있다.
    3. 시간 복잡도 : 삽입, 삭제, 탐색 작업은 모두 O(log n)의 시간 복잡도를 가집니다.
    4. 응용 : 레드-블랙 트리는 STL(map, set)에서 사용되며 Java의 TreeMap, TreeSet과 같은 곳에서 사용됩니다.

6. 힙 (Heap)
1. 정의 : 힙은 최대값이나 최소값을 빠르게 찾기 위해 사용되는 트리 자료구조이다. 일반적으로 이진 힙(Binary Heap)이 많이 사용된다.
2. 특징 :
    1. 이진 힙 :
        1. 최대 힙 (Max Heap) : 부모 노드가 자식 노드보다 항상 크거나 같은 값을 가지며 루트 노드가 트리 내의 최대값이 된다.
        2. 최소 힙 (Min Heap) : 부모 노드가 자식 노드보다 항상 작거나 같은 값을 가지며 루트 노드가 트리 내의 최소값이 된다.
    2. 완전 이진 트리 : 이진 힙은 완전 이진 트리 형태를 가지며 이는 모든 레벨이 완전히 채워져 있거나 마지막 레벨에서 왼쪽부터 채워져 있는 트리이다.
    3. 응용 : 힙은 우선순위 큐의 구현에 주로 사용된다. 힙 정렬(Heap Sort) 알고리즘에서도 사용된다.
    4. 시간 복잡도 : 삽입과 삭제 연산은 O(log n)의 시간 복잡도를 가지며 최대값이나 최소값을 찾는 연산은 O(1)입니다.

 7. 트라이 (Trie)
1. 정의 : 트라이는 문자열을 효율적으로 저장하고 탐색하는 데 최적화된 트리 자료구조로 특히 문자열의 접두사를 기반으로 동작한다.
2. 특징 :
    1. 구조 : 트라이는 각 노드가 문자열의 특정 문자나 접두사를 나타내며 루트 노드부터 시작하여 문자열의 각 문자에 따라 트리의 경로를 따라가며 저장한다.
    2. 문자열 탐색 : 문자열의 존재 여부를 빠르게 탐색할 수 있으며 접두사 기반의 검색에 매우 효율적이다.
    3. 응용 :
        1. 자동완성 시스템 : 트라이는 자동완성 기능에서 사용자 입력의 접두사를 기반으로 가능한 단어를 빠르게 제안하는 데 사용된다.
        2. 사전 구현 : 많은 단어를 포함하는 사전에서 빠른 검색을 위해 트라이가 사용된다.
        3. IP 주소 라우팅 : IP 주소의 접두사를 기반으로 하는 라우팅 테이블에서 활용된다.
    4. 시간 복잡도 : 탐색과 삽입 작업은 O(L)의 시간 복잡도를 가지며, 여기서 L은 탐색하려는 문자열의 길이이다.